import { createSlice } from '@reduxjs/toolkit'

let nextTodoId = 0

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: {
      reducer(state, action) {
        const { id, text } = action.payload
        state.push({ id, text, completed: false })
      },
      prepare(text) {
        return { payload: { text, id: nextTodoId++ } }
      },
    },
    toggleTodo(state, action) {
      const todo = state.find((todo) => todo.id === action.payload)
      if (todo) {
        todo.completed = !todo.completed
      }
    },
  },
})

export const { addTodo, toggleTodo } = todosSlice.actions

export default todosSlice.reducer

/*
!  createSlice takes an options object as its argument, with these options:
    ! name: a string that is used as the prefix for generated action types
    ! initialState: the initial state value for the reducer
    ! reducers: an object, where the keys will become action type strings, and the functions are reducers that will be run when
    ! that action type is dispatched. (These are sometimes referred to as "case reducers", because they're similar to a case in
    ! a switch statement)


? So, the addTodo case reducer function will be run when an action with the type "todos/addTodo" is dispatched.
? There's no default handler here. The reducer generated by createSlice will automatically handle all other action types by 
? returning the current state, so we don't have to list that ourselves.


!Exporting the Slice Functions
!createSlice returns an object that looks like this:

{
    name: "todos ",
    reducer: (state, action) => newState,
    actions: {
      addTodo: (payload) => ({type: "todos/addTodo", payload}),
      toggleTodo: (payload) => ({type: "todos/toggleTodo", payload})
    },
    caseReducers: {
      addTodo: (state, action) => newState,
      toggleTodo: (state, action) => newState,
    }
  }

  */

//! RTK allows you to customize how the payload field is created in your action objects. If you need to customize the payload
//! there, you can do so by passing an object containing reducer and prepare functions to the reducers object, instead of
// ! just the reducer function by itself:

//! Note that the "prepare callback" must return an object with a field called payload inside!
